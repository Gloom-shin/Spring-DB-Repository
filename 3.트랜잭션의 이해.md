# 스프링 DB 강의 리뷰📽
> LoadMap Part : 스프링 DB 1편 - 데이터 접근 핵심 원리 - 2022-05-15  
> Section : 3.트랜잭션 이해  
> CreateDate : 2022.10.31
> UpdateDate : 2022.11.01


## 사용한 스펙
> Spring Boot 버전 : Spring Boot 2.7.3  
> Java 버전 : java 11    
> Gradle 버전: gradle-7.5

### 목차

<br></br>
### IntelliJ 단축키
 - Ctrl + F6 : 메소드에 사용시 메소드 명, 파라미터위치를 수정할 수 있다.
<br></br>
<br></br>
# 1. 트랜잭션의 개념
> 데이터를 저장할 때 단순히 파일에 저장해도 되지만, 데이터베이스에 저장하는 이유는 무엇일까?
 - 여러가지 이유가 있지만, 가장 대표적인 이유는 데이터베이스의 트랜잭션 지원 때문이다. 
 - 대표적인 예시로 1번 -> 2번 계좌이체를 예시로 드는데, 중간에 하나라도 실패하면 거래 전의 상태로 되돌아 갈수 있어야한다.
   - 모든 작업이 성공해서 데이터베이스에 정상 반영하는 것 : Commit(커밋)
   - 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것 : Rollback(롤백)

## 트랜잭션 ACID
 - 트랜잭션은 4가지 ACID를 보장해야한다.
### 원자성(Atomicity)
 - 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하거나 모두 실패해야 한다
### 일관성(Consistency)
 - 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 
   - 예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
### 격리성(Isolation)
 - 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다
   - 예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다
   - 격리성은 동시성과 관련된 성능 이슈로 인해 트랜잭션 격리 수준(Isolation level)을 선택할 수 있다.
### 지속성(Durability)
 - 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
 - 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다

### 트랜잭션 격리 수준 - Isolation level
- 트랜잭션은 위 4가지를 보장해야되지만, 문제는 격리성에 있다. 
  - 격리성을 완벽히 보장하려면 거의 순서대로 실행해야되는데, 이경우 동시 처리 성능이 매우 나빠진다. 
  - 그래서, 상황에 따라 격리성의 정도를 변화할 수 있게 했는데, ANSI표준은 격리수준은 4단계로 나누어 정의한다.
  
1. READ UNCOMMITED(커밋되지 않은 읽기)
2. READ COMMITTED(커밋된 읽기)
3. REPEATABLE READ(반복 가능한 읽기)
4. SERIALIZABLE(직렬화 가능)


<br></br>
<br></br>

# 데이터베이스 연결 구조와 DB 세션
 - 트랜잭션을 더 자세히 이해하기 전, 데이터베이스 서버 연결구조와 DB세션에 대해 알고 있어야 한다. 

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/198901632-d9fe51f3-0675-4ff1-94f4-b9b0ecc4d46b.png" width="80%"></p>

- 답은 간단하다, DB 접근 툴 같은 클라이언트를 사용해서 데이터베이스에 접근한다. 
- 그럼 클라이언트와 데이터베이스 커넥션을 맺게되는데, 이때 데이터베이스 서버내부에는 세션을 만든다.
- 그리고  해당 커넥션을 통한 모든 요청은 세션을 통해서 실행된다. 
- 즉, SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행시킨다는 것이다. 
  - 세션은 트랜잭션을 시작하고, 종료(커밋/롤백)한다.
  - 사용자가 커넥션을 닫거나, DBA(DBadmin)가 세션을 강제로 종료하면 종료된다. 
- 커넥션 풀도 이와 같은 맥락이다.

<br></br>
<br></br>

# 트랜젝션 - DB 개념 이해 
- 데이터 변경 쿼리를 실행하고 데이터베이스에 그 결과를 반영하려면 커밋 명령어인 commit 을 호출하고, 결과를 반영하고 싶지 않으면 롤백 명령어인 rollback 을 호출하면 된다.
- 커밋을 호출하기 전까지는 임시로 데이터를 저장하는 것이다. 따라서 해당 트랜잭션을 시작한 세션(사용자)에게만 변경 데이터가 보이고 다른 세션(사용자)에게는 변경 데이터가 보이지 않는다.
- 처음 데이터상태는 아래와 같다고 가정하고, 세션을 2개가 만들어 졌다.
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/198904496-4b05b901-d52e-41b0-b94f-ce0160c84a1c.png" width="80%"></p>

- 세션1, 세션2 둘다 가운데 있는 기본 테이블을 조회하면 해당 데이터가 그대로 조회된다.
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/198904501-a0a78bf8-0b74-4505-8d7a-80ce9dff4810.png" width="80%"></p>

- 세션1에서 트랜잭션을 시작하면서 신규회원1을 DB에 추가했다. 하지만 커밋하기 전에 세션2는 select 쿼리를 실행해도 신규 회원들을 조회할 수 없다. 
- 여기서 헤깔릴 수 있는 것은 세션1이 select 쿼리를 실행해서 본인이 입력한 신규 회원1를 조회할 수 있다는 것이다.
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/198904505-239d18d5-2131-450e-a9ab-e7687923f41d.png" width="80%"></p>

- 세션1이 신규 데이터를 추가한 후에 commit 을 호출했기에, 다른 세션에서도 회원 테이블을 조회하면 신규 회원을 확인할 수 있다.
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/198904510-7f0ab931-9aa7-4e26-988c-990cd648c1d1.png" width="80%"></p>

- 만약, 세션1이 commit이 아닌 rollback를 호출했다면, 처음 상태로 복구 된다.
- 수정하거나 삭제한 데이터도 rollback 을 호출하면 모두 트랜잭션을 시작하기 직전의 상태로 복구된다.


<br></br>
<br></br>
# 트랜젝션 - 자동 커밋, 수동 커밋
### 자동커밋 
 - 각각의 쿼리 실행 직후에 자동으로 커밋을 호출한다. 
   - 따라서 커밋이나 롤백을 직접 호출하지 않아도 되는 편리함이 있다.
 - 하지만 쿼리를 하나하나 실행할 때 마다 자동으로 커밋이 되어버리기 때문에 우리가 원하는 트랜잭션 기능을 제대로 사용할 수 없다
```roomsql
set autocommit true; --자동 커밋 모드 설정
insert into member(member_id, money) values ('data1',10000); --자동 커밋
insert into member(member_id, money) values ('data2',10000); --자동 커밋
```
- 따라서 commit , rollback 을 직접 호출하면서 트랜잭션 기능을 제대로 수행하려면 자동 커밋을 끄고 수동 커밋을 사용해야 한다.

### 수동 커밋
 - 보통 자동 커밋 모드가 기본으로 설정된 경우가 많기 때문에, 수동 커밋 모드로 설정하는 것을 트랜잭션을 시작한다고 표현할 수 있다.
   - 한번 설정하면 해당 세션에서는 계속 유지된다.
 - 수동 커밋 설정을 하면 이후에 꼭 commit , rollback 을 호출해야 한다.
```roomsql
set autocommit false; --수동 커밋 모드 설정
insert into member(member_id, money) values ('data3',10000);
insert into member(member_id, money) values ('data4',10000);
commit; --수동 커밋
```

<br></br>
<br></br>

# DB락
## DB락 - 변경
> 세션1이 트랜잭션을 시작하고 데이터를 수정하는 동안 아직 커밋을 수행하지 않았는데,   
> 세션2에서 동시에 같은 데이터를 수정하게 되면 여러가지 문제가 발생한다. 바로 트랜잭션의 원자성이 깨지는 것이다.  
> 더해서 세션1이 중간에 롤백을 하게 되면 세션2는 잘못된 데이터를 수정하는 문제가 발생한다.

- 세션 1,2 가 거의 동시에 접근하는 예시로 알아보자 
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/198982834-8675e61e-8557-4bee-b383-73405c05fdde.png" width="80%"></p>

- 세션1은 5000원으로, 세션2는 2000원으로 변경하는 트랜잭션을 거의 동시에 시작하였다.
- 둘중 먼저 요청한 세션이 락을 먼저 획득한다.(세션1이 더 빨리 요청함)
  - 세션1은 락을 획득했으므로, 로우에 update sql을 수행한다.
  - 세션2는 락이 없으므로 대기를 한다.
    - 물론 무한정 대기하는 것이 아닌, 대기 시간을 넘기면 타임아웃 오류가 발생한다.
    - 타임아웃오류는 다음과 같다.  
    <p align="center"><img src="https://user-images.githubusercontent.com/104331549/198988730-03088ce8-fe60-406d-b2bc-d75f65532e36.png" width="80%"></p>
    

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/198985373-e41741ca-bad2-4ab4-9d2c-857dfbf517bc.png" width="80%"></p>

 - 수행이 완료된 세션1은 Lock를 반납한다. 
 - 그리고 대기중이던 세션2가 가져가 아래와같이 수행하고, commit이나, rollback으로 트랜잭션이 완료되면 Lock를 반납한다.
<p align="center"><img src="https://user-images.githubusercontent.com/104331549/198985395-c4a47644-8e08-4651-8ba8-6a32476eafc6.png" width="80%"></p>

- 이후, 세션2도 같은 과정을 거친다.

<br></br>
<br></br>

## DB락 - 조회
- 일반적으로 조회는 락을 사용하지 않는다. 
- 데이터를 조회할 때도 락을 획득하는 것으로 `select for update` 구문을 사용하면 된다
- 이렇게 하면 세션1이 조회 시점에 락을 가져가버리기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다.
  - 물론 다른 세션에서도 조회는 가능하다.(변경 전 조회) 
  - 조회때 락을 가져간 세션이 커밋/롤백을 하여 락을 반납하여야 다른 세션에서 변경 할 수 있다.
> 조회 시점에 락이 필요한 경우는 언제일까?
- 예를 들어서 애플리케이션 로직에서 memberA 의 금액을 조회한 다음에 이 금액 정보로 애플리케이션에서 어떤 계산을 수행한다.   
- 그런데 이 계산이 돈과 관련된 매우 중요한 계산이어서 계산을 완료할 때 까지 memberA 의 금액을 다른곳에서 변경하면 안된다.(워낙 금액 정산이 많은 경우) 
- 이럴 때 조회 시점에 락을 획득하면 된다

### 추가 팁
- 트랜잭션과 락은 데이터베이스마다 실제 동작하는 방식이 조금씩 다르기 때문에, 해당 데이터베이스 메뉴얼을 확인해보고, 의도한대로 동작하는지 테스트한 이후에 사용하는 것이 좋다.
- 물론 왠만해서는 위 개념으로 구성되어 있긴하다.

<br></br>
<br></br>

# 트랜잭션 적용
- 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다.
  - 비즈니스 로직이 잘못되면 해당 비즈니스 로직으로 인해 문제가 되는 부분을 함께 롤백해야 하기 때문이다
- 그런데 트랜잭션을 시작하려면 **커넥션이 필요**하다.
  - 결국 서비스 계층에서 커넥션을 만들고, 트랜잭션 커밋 후에 커넥션을 종료해야 한다
- 애플리케이션에서 DB 트랜잭션을 사용하려면 트랜잭션을 사용하는 동안 "**같은 커넥션**"을 유지해야한다. 그래야 같은 세션을 사용할 수 있다
> 가장 단순한 방법은 커넥션을 파라ㅍ미터로 전달해서 같은 커넥션을 사용하는 것

### 같은 커넥션 파라미터로 전달하기
 - [같은 커넥션 파라미터로 전달 코드](/practice_code/repository/MemberRepositoryV2.java)
    - findById 와 update 메소드에 커넥션을 파라미터로 받는 메소드 추가(오버로딩)
 - [비즈니스로직 코드 ](/practice_code/service/MemberServiceV2.java)
   - 여기서 중요한 것은 커넥션을 사용한 후, 커밋 혹은 롤백을 했을 때 보통의 경우에는 커넥션을 닫으면 종료되어 세션이 초기화되겠지만
   - 커넥션 풀로 반납하는 경우에는 종료가 되질않아, 바뀐 설정도 유지가 된다.(`con.setAutoCommit(false);`)
     - 그렇기에 `con.setAutoCommit(true);`로 원상복귀 시켜주고, `con.close()`를 하는 것이다.

### 같은 커넥션 파라미터로 전달하기 테스트
 - [테스트 코드](/test_code/service/MemberServiceV2Test.java)
 - 트랜잭션 덕분에 계좌이체가 실패해도 롤백을 수행해서 모든 데이터를 정상적으로 초기화됨을 알 수 있었다.

<br></br>
<br></br>

## 남은 문제점 
 - 애플리케이션에서 DB 트랜잭션을 적용하려면 서비스 계층이 매우 지저분해지고, 생각보다 매우 복잡한 코드를 요구한다
   - 매번 커넥션을 파라미터로 전부 전달해줘야된다.
   - 트랜잭션을 처리하기위해, 설정(시작/원상복귀등)과 예외처리가 매번 넣어줘야한다. 
 > 그래서 이러한 문제를 스프링에서 오랜시간동안 많은 과정을 거쳐 왔다. 


## 느낀점 😌
 - 트랜잭션이 스프링 고유의 기능(?)인줄 알았었는데, 이번 강의를 통해 SQL의 기능임을 알게되었다. 
 - 그리고 Commit과 Rollback의 의미도 더 명확하게 알게되면서 버전관리툴인 Git에서의 Commit의 의미도 알게되었다.
 - 우리가 흔히 SQL문을 쓸때는 `autoCommit`임을 알게되었다.

### 참고 링크
 - [트랜잭션 확인하기위한 서비스로직](/practice_code/service/MemberServiceV1.java)
 - [트랜잭션 확인하기위한 테스트 코드](/test_code/service/MemberServiceV1Test.java)