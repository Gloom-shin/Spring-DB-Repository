# 스프링의 강의 리뷰📽

> LoadMap Part : 스프링 DB 1편 - 데이터 접근 핵심 원리 - 2022-05-15  
> Section : 4.스프링과 문제해결 - 트랜잭션   
> CreateDate : 2022.11.01  
> UpdateDate :

## 사용한 스펙

> Spring Boot 버전 : Spring Boot 2.7.3  
> Java 버전 : java 11    
> Gradle 버전: gradle-7.5

<br></br>
<br></br>

# 1. 문제점들

> 먼저 가장 단순하면서 많이 사용하는 애플리케이션의 구조를 알아보자

- 3가지 계층으로 되어있다.

## 애플리케이션 구조

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/199083658-7a2eacc7-6d27-4d14-a1e0-2a780adb6fcc.png" width="80%"></p>

### 프레젠테이션 계층

- UI와 관련된 처리(view)
- 웹 요청과 응답(request/response)
- 사용자 요청을 검증(validation)

> 주 사용 기술: 서블릿과 HTTP 같은 웹 기술, 스프링 MVC

### 서비스 계층

- 비즈니스 로직을 담당

> 주 사용 기술: 가급적 특정 기술에 의존하지 않고, 순수 자바 코드로 작성

### 데이터 접근 계층

- 실제 데이터베이스에 접근하는 코드

> 주 사용 기술: JDBC, JPA, File, Redis, Mongo ...

<br>

## 순수한 서비스 계층

- 핵심은 비즈니스 로직이 들어있는 서비스 계층이다
- UI(웹)와 관련된 부분이나, 데이터 저장 기술은 다른 기술로 변경해도, 비즈니스 로직은 최대한 변경없이 유지되어야 한다.
- 즉, 서비스 계층은 특정 기술에 종속적이지 않게 개발해야된다는 것이다.
    - 이렇게 계층을 나눈 이유도 서비스 계층을 최대한 순수하게 유지하기 위한 목적이 크다
    - 기술에 종속적인 부분은 프레젠테이션 계층, 데이터 접근 계층
        - 프레젠테이션 계층 : HTTP API를 사용하다가 GRPC같은 기술로 변경되면, 해당 계층 코드만 변경하면 됨
        - 데이터 접근 계층 :  JDBC를 사용하다가 JPA 로 변경되면, 해당 계층만 바꾸면된다.

> 그럼 어떻게 서비스 계층을 순수하게 유지할까?

### MemberServiceV1

- 만들어놨던 코드를 보자

```java

@RequiredArgsConstructor
public class MemberServiceV1 {
    private final MemberRepositoryV1 memberRepository;

    public void accountTransfer(String fromId, String toId, int money) throws SQLException { // 중요한 곳은 여기
        Member fromMember = memberRepository.findById(fromId);
        Member toMember = memberRepository.findById(toId);

        memberRepository.update(fromId, fromMember.getMoney() - money);
        validation(toMember);
        memberRepository.update(toId, toMember.getMoney() + money);

    }

    private void validation(Member toMember) {
        if (toMember.getMemberId().equals("ex")) {
            throw new IllegalStateException("이체중 예외 발생");
        }
    }
}
```

- 언뜻 보기에 특정 기술에 종속적이지 않고, 순수한 비즈니스 로직으로만 보일 수 있지만,
    - SQLException 이라는 JDBC 기술에 의존한다는 점이 있다.
    - 이 부분은 memberRepository 에서 올라오는 예외이기 때문에 memberRepository 에서 해결해야 한다.

### MemberServiceV2

- 트랜잭션을 이용한 `V2` 버전도 트랜잭션을 사용하기 위해서 `javax.sql.DataSource` , `java.sql.Connection` , `java.sql.SQLException` 같은 JDBC 기술에
  의존해야 한다는 점이 있다.
- 결과적으로 비즈니스 로직보다 JDBC를 사용해서 트랜잭션을 처리하는 코드가 더 많다

<br></br>
<br></br>

## 문제 정리

> 문제점을 정리하면 크게 3가지이다.

### 1. 트랜잭션 문제

- JDBC 구현 기술이 서비스 계층에 누수되는 문제
    - 트랜잭션을 적용하기 위해 JDBC 구현 기술이 서비스 계층에 누수되었다
- 트랜잭션 동기화 문제
    - 같은 트랜잭션을 유지하기 위해 커넥션을 파라미터로 넘겨야 한다
- 트랜잭션 적용 반복 문제
    - 트랜잭션 적용 코드를 보면 반복이 많다. try , catch , finally ..

### 2. 예외 누수 문제

- SQLException 은 JDBC 전용 기술이다
    - JDBC 구현 기술 예외가 서비스 계층으로 전파된다

### 3. JDBC 반복 문제

- 이 코드들은 유사한 코드의 반복이 너무 많다
    - try , catch , finally 반복
    - 커넥션을 열고, PreparedStatement 를 사용하고, 결과를 매핑하고... 실행, 다시 반납 반복

> 그럼 이러한 문제들을 어떻게 해결할까?
> 스프링을 사용해서 우리 애플리케이션이 가진 문제들을 하나씩 해결해보자.

<br></br>
<br></br>

# 트랜잭션 추상화

- 먼저 JDBC로 트랜잭션 구현할 때랑, JPA로 트랜잭션 구현할 때 어떻게 달라지는지 알아보자

### JDBC 트랜잭션 코드 예시

```java
public class JDBCServiceCode {
    //.. 생략
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Connection con = dataSource.getConnection();
        try {
            con.setAutoCommit(false); //트랜잭션 시작
            //비즈니스 로직
            bizLogic(con, fromId, toId, money);
            con.commit(); //성공시 커밋
        } catch (Exception e) {
            con.rollback(); //실패시 롤백
            throw new IllegalStateException(e);
        } finally {
            release(con);
        }
    }
}
```

### JDBC 트랜잭션 코드 예시

```java
public class JPAServiceCode {
    //.. 생략
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook"); //엔티티 매니저 팩토리 생성
        EntityManager em = emf.createEntityManager(); //엔티티 매니저 생성
        EntityTransaction tx = em.getTransaction(); //트랜잭션 기능 획득
        try {
            tx.begin(); //트랜잭션 시작
            logic(em); //비즈니스 로직
            tx.commit();//트랜잭션 커밋
        } catch (Exception e) {
            tx.rollback(); //트랜잭션 롤백
        } finally {
            em.close(); //엔티티 매니저 종료
        }
        emf.close(); //엔티티 매니저 팩토리 종료
    }
}
```

> 이렇게 트랜잭션을 사용하는 코드는 데이터 접근 기술마다 다르다.  
> 그렇기 떄문에 기술을 바꾸게되면, 서비스계층도 바꿔야되는 문제가 발생한다.
> 이 문제를 해결하려면 트랜잭션 기능을 추상화하면 된다

## 트랜잭션 추상화 인터페이스

- 결국, 트랜잭션은 시작하고, 비즈니스 로직의 수행이 끝나면 커밋하거나 롤백하면 된다

```java
public interface TxManager {
    begin(); // 시작

    commit(); // 커밋

    rollback(); // 롤백
}
```

- 그리고 이 인터페이스를 기반으로 각각의 기술에 맞는 구현체를 만들면된다.
- 스프링은 이미 이런 문제를 해결할 인터페이스와 구현체를 다 해두었다.
- 우리는 가져다 사용하기만하면 된다.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/199321264-ccfdecf5-07bd-49a0-9b4d-a9f7889823b3.png" width="80%"></p>

- 스프링 트랜잭션 추상화의 핵심은 `PlatformTransactionManager` 인터페이스이다.
    - `org.springframework.transaction.PlatformTransactionManager`

<br></br>
<br></br>

# 트랜잭션 동기화

> 스프링이 제공하는 트랜잭션 매니저는 크게 2가지 역할을 한다.

- 위에서 언급한 트랜잭션 추상화
- 리소스 동기화

### 리소스 동기화

- 트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 데이터베이스 커넥션을 유지해아한다.
    - 이전에는 파라미터로 커넥션을 전달하는 방법을 사용했다.
- 스프링은 이것을 쓰레드 로컬(`ThreadLocal`)을 사용해서 커넥션을 동기화 해준다.
    - 쓰레드 로컬을 사용하면 각각의 쓰레드마다 별도의 저장소가 부여된다. 따라서 해당 쓰레드만 해당 데이터에 접근할 수 있다.
    - 여기서 쓰레드 로컬은 중요하니까, 따로 다루기로 하자.

<p align="center"><img src="https://user-images.githubusercontent.com/104331549/199325949-8126f1e5-729c-4170-a0df-fa9fdad8d3d8.png" width="80%"></p>

- 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 커넥션을 획득하면 된다

## 트랜잭션 동기화 매니저

- `org.springframework.transaction.support.TransactionSynchronizationManager`
- 트랜잭션 동기화 매니저 클래스를 열어보면 쓰레드 로컬을 사용하는 것을 확인할 수 있다

<br></br>
<br></br>

# 트랜잭션 문제 해결 - 트랜잭션 매니저1

- `DataSourceUtils`으로 커넥션 생성과 닫음을 처리하면, 커넥션 파라미터로 전달해야되는 문제를 동기화로 해결할 수 있다.
    - DataSourceUtils.getConnection(dataSource)  - 커넥션 연결
    - DataSourceUtils.releaseConnection(커넥션, dataSource)
        - JdbcUtils.closeConnection(con);로 닫아주면 안된다.

## DataSourceUtils.getConnection()

- 트랜잭션 동기화 매니저가 관리하는 커넥션이 있으면 해당 커넥션을 반환한다
- 트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 새로운 커넥션을 생성해서 반환한다
- DataSourceUtils 코드를 보면 아래와 같다.
    - 커넥션을 받아오는 `getConnection()`메소드 코드를 보면 `doGetConnection(dataSource)`를 실행한다.

### DataSourceUtils.java

```java
package org.springframework.jdbc.datasource;

public abstract class DataSourceUtils {
    //.. 이하 생략
    public static Connection getConnection(DataSource dataSource) throws CannotGetJdbcConnectionException {
        try {
            // 여기가 중요!
            return doGetConnection(dataSource);

        } catch (SQLException ex) {
            throw new CannotGetJdbcConnectionException("Failed to obtain JDBC Connection", ex);
        } catch (IllegalStateException ex) {
            throw new CannotGetJdbcConnectionException("Failed to obtain JDBC Connection: " + ex.getMessage());
        }
    }

    // doGetConnection() 메소드
    public static Connection doGetConnection(DataSource dataSource) throws SQLException {
        Assert.notNull(dataSource, "No DataSource specified");
        //여기서 동기화 매니저에서 커넥션을 가져오는 걸 알 수 있다. 
        //TransactionSynchronizationManager = 트랜잭션 동기화 매니저
        ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);
        if (conHolder != null && (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) {
            conHolder.requested();
        }
        // 이하 생략
    }
}
```

<br></br>

## DataSourceUtils.releaseConnection()

- 커넥션을 con.close() 를 사용해서 직접 닫아버리면 커넥션이 유지되지 않는 문제가 발생한다.
    - 이 커넥션은 이후 로직은 물론이고, 트랜잭션을 종료(커밋, 롤백)할 때 까지 살아있어야 한다.
- DataSourceUtils.releaseConnection() 을 사용하면 커넥션을 바로 닫는 것이 아니다.
    - 트랜잭션을 사용하기 위해 동기화된 커넥션은 커넥션을 닫지 않고 그대로 유지해준다.
    - 트랜잭션 동기화 매니저가 관리하는 커넥션이 없는 경우 해당 커넥션을 닫는다.

### DataSourceUtils.java

```java
package org.springframework.jdbc.datasource;

public abstract class DataSourceUtils {
    //.. 이하 생략

    public static void releaseConnection(@Nullable Connection con, @Nullable DataSource dataSource) {
        try {
            // 여기가 중요!    
            doReleaseConnection(con, dataSource);

        } catch (SQLException ex) {
            logger.debug("Could not close JDBC Connection", ex);
        } catch (Throwable ex) {
            logger.debug("Unexpected exception on closing JDBC Connection", ex);
        }
    }

    //doReleaseConnection() 메소드
    public static void doReleaseConnection(@Nullable Connection con, @Nullable DataSource dataSource) throws SQLException {
        if (con == null) {
            return;
        }
        if (dataSource != null) {
            //여기서 커넥션 동기화 매니저에서 커넥션을 가져오는 걸 알 수 있다. 
            ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);
            if (conHolder != null && connectionEquals(conHolder, con)) {
                // It's the transactional Connection: Don't close it.
                // 만약 커넥션 동기화 매니저에서 관리하는 커넥션이라면 닫을 수 없다.
                conHolder.released();
                return;
            }
        }
        doCloseConnection(con, dataSource);
    }
}
```
## 서비스
 - 이제 JDBC의 기술인 DataSource를 직접 적용하지않고 추상화할 수 있는 인터페이스 `PlatformTransactionManager`로 넣으면된다.
   - DI가 적용되기 때문에, JDBC에 의존하지 않게 된다. 
 - 게다가 서비스 계층에서, 커넥션을 파라미터로 전달하지도 않게 된다.
 - 또한, 릴리즈처리도 서비스 계층에서 필요없게 된다.(매니저가 해줌) 
### 참고 코드
- [트랜잭션 매니저를 서비스계층 MemberServiceV3_1.java 코드 보기](/practice_code/service/MemberServiceV3_1.java)

## 테스트





<p align="center"><img src="" width="80%"></p>


<a name=""></a>
<br></br>
<br></br>

## 느낀점 😌

### 참고 링크